<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, interactive-widget=resizes-content">
    <title>VOCA STACK Mobile</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;700&family=Roboto+Mono:wght@400;700&display=swap');
        
        /* ê¸°ë³¸ ë ˆì´ì•„ì›ƒ ì„¤ì • */
        html, body {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #0f172a;
            color: #e2e8f0;
        }

        body {
            display: flex;
            flex-direction: column;
        }

        /* 1. ìƒë‹¨ í—¤ë” */
        header {
            flex: 0 0 50px;
            z-index: 30;
            transition: all 0.3s;
        }

        /* 2. ê²Œì„ ì˜ì—­ */
        main#gameArea {
            flex: 1 1 auto;
            position: relative;
            background: radial-gradient(circle at center, #1e293b 0%, #0f172a 100%);
            overflow: hidden;
            width: 100%;
            /* ê°€ë¡œì„  ê·¸ë¦¬ë“œ ë°°ê²½ (ë ˆì¸ ê°€ì´ë“œ) */
            background-image: linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 100% 40px; /* 40px ê°„ê²© */
        }

        /* 3. í•˜ë‹¨ ì…ë ¥ë°” */
        .input-bar {
            flex: 0 0 auto;
            z-index: 50;
            background: #1e293b;
            border-top: 1px solid #334155;
            width: 100%;
        }

        .neon-text { text-shadow: 0 0 5px #fff, 0 0 10px #8b5cf6; }
        
        .word-block {
            position: absolute;
            color: #ffffff;
            font-family: 'Roboto Mono', 'Noto Sans KR', monospace;
            font-weight: bold;
            font-size: 0.9rem;
            height: 34px; /* ë†’ì´ ê³ ì • (ë ˆì¸ì— ë§ì¶¤) */
            line-height: 32px; /* í…ìŠ¤íŠ¸ ìˆ˜ì§ ì •ë ¬ */
            background: rgba(30, 41, 59, 0.95);
            padding: 0 10px;
            border-radius: 4px;
            border: 1px solid rgba(148, 163, 184, 0.4);
            white-space: nowrap;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            z-index: 10;
            will-change: transform;
            display: flex;
            align-items: center;
        }

        .word-block.stacked {
            background: rgba(51, 65, 85, 0.95);
            border-color: #64748b;
            color: #cbd5e1;
            box-shadow: none;
            transition: transform 0.2s ease-out; /* ë¶€ë“œëŸ¬ìš´ ì´ë™ */
        }

        .meaning-afterimage {
            position: absolute;
            font-family: 'Noto Sans KR', sans-serif;
            font-weight: bold;
            font-size: 1rem;
            white-space: nowrap;
            padding: 4px 8px;
            border-radius: 4px;
            z-index: 20;
            color: #fbbf24;
            background: rgba(251, 191, 36, 0.15);
            border: 2px solid #fbbf24;
            animation: fadeOutBlock 0.6s ease-out forwards;
        }

        @keyframes fadeOutBlock {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(1.15); }
        }

        /* ì„¸ë¡œ ìœ„í—˜ ë¼ì¸ (ì™¼ìª½ ëìœ¼ë¡œ ì´ë™) */
        .danger-line-vertical {
            position: absolute;
            top: 0;
            left: 0; 
            width: 4px; 
            height: 100%;
            background: linear-gradient(90deg, #ef4444, transparent);
            box-shadow: 0 0 15px #ef4444;
            z-index: 5;
            opacity: 0.6;
            pointer-events: none;
        }
        
        .limit-label {
            position: absolute;
            top: 10px;
            left: 5px; 
            font-size: 10px;
            color: #ef4444;
            opacity: 0.7;
            letter-spacing: 1px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            pointer-events: none;
        }

        .modal-overlay {
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(4px);
            z-index: 100;
        }
        
        select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%239ca3af' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.5rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            -webkit-appearance: none;
            appearance: none;
        }
    </style>
</head>
<body>

    <!-- 1. Header -->
    <header class="flex items-center justify-between px-4 bg-slate-900 border-b border-slate-800 transition-colors duration-300" id="mainHeader">
        <div class="flex items-center gap-2" id="appLogoGroup">
            <i class="fas fa-layer-group text-violet-400"></i>
            <span class="font-bold text-violet-100 text-sm tracking-widest">VOCA STACK M</span>
        </div>
        
        <div class="flex gap-3 text-sm ml-auto">
            <div class="flex items-center gap-1 text-yellow-400">
                <i class="fas fa-star text-xs"></i>
                <span id="scoreDisplay" class="font-mono font-bold">0</span>
            </div>
            <div class="w-px h-4 bg-slate-700 my-auto"></div>
            <button onclick="GameApp.openOptions()" class="text-slate-400 hover:text-white p-1">
                <i class="fas fa-cog"></i>
            </button>
            <button id="pauseBtn" class="text-yellow-500 hidden p-1">
                <i class="fas fa-pause"></i>
            </button>
            <button onclick="GameApp.resetGame()" id="stopBtn" class="text-red-500 hidden p-1">
                <i class="fas fa-stop"></i>
            </button>
        </div>
    </header>

    <!-- 2. Game Area -->
    <main id="gameArea">
        <div class="danger-line-vertical"></div>
        <div class="limit-label">LIMIT LINE</div>

        <!-- Start Screen -->
        <div id="startScreen" class="absolute inset-0 flex flex-col items-center justify-center z-40 bg-slate-900 px-6 text-center overflow-y-auto">
            <h2 class="text-4xl font-bold text-white neon-text mb-2">VOCA STACK</h2>
            <p class="text-slate-400 text-xs mb-8">ê°€ë¡œ & ëª¨ë°”ì¼ ë²„ì „</p>
            
            <div class="w-full mb-6 text-left">
                <label class="text-xs text-slate-400 ml-1 mb-1 block">í•™ìŠµí•  ë‹¨ì–´ì¥ ì„ íƒ</label>
                <select id="wordListSelect" class="w-full bg-slate-800 text-white p-4 rounded-xl border border-slate-600 focus:border-violet-500 outline-none text-sm transition-colors">
                </select>
                <div class="text-[10px] text-slate-500 mt-1 ml-1" id="wordCountPreview">ë‹¨ì–´ ìˆ˜: 0ê°œ</div>
            </div>

            <div class="grid grid-cols-1 w-full gap-3 mb-6">
                <button onclick="GameApp.startGame('normal')" class="w-full py-4 bg-violet-600 active:bg-violet-700 rounded-xl shadow-lg border border-violet-500 flex items-center justify-center gap-3 transition-transform active:scale-95">
                    <i class="fas fa-play"></i> <span class="font-bold">ì¼ë°˜ ëª¨ë“œ</span>
                </button>
                <button onclick="GameApp.startGame('practice')" class="w-full py-4 bg-emerald-600 active:bg-emerald-700 rounded-xl shadow-lg border border-emerald-500 flex items-center justify-center gap-3 transition-transform active:scale-95">
                    <i class="fas fa-infinity"></i> <span class="font-bold">ì—°ìŠµ ëª¨ë“œ</span>
                </button>
            </div>
            
            <div class="flex gap-2 w-full">
                <input type="file" id="fileInput" accept=".txt,.csv" class="hidden">
                <button onclick="document.getElementById('fileInput').click()" class="flex-1 py-3 bg-slate-800 rounded-lg text-xs border border-slate-700 text-slate-300">
                    <i class="fas fa-folder-open text-green-400 mr-1"></i> íŒŒì¼ ì—´ê¸°
                </button>
                <button onclick="GameApp.openOptions()" class="flex-1 py-3 bg-slate-800 rounded-lg text-xs border border-slate-700 text-slate-300">
                    <i class="fas fa-cog text-slate-300 mr-1"></i> ì˜µì…˜
                </button>
            </div>
        </div>
    </main>

    <!-- 3. Input Bar -->
    <div class="input-bar p-3 pb-safe flex gap-2">
        <input type="text" id="wordInput" 
            class="flex-1 bg-slate-800 text-white px-4 py-3 rounded-lg border border-slate-600 focus:border-violet-500 focus:outline-none text-lg"
            placeholder="ì…ë ¥..." autocomplete="off" disabled>
        
        <button id="fireBtn" class="bg-violet-600 text-white px-5 rounded-lg active:bg-violet-700 active:scale-95 transition-transform flex items-center justify-center disabled:opacity-50">
            <i class="fas fa-paper-plane text-xl"></i>
        </button>
    </div>

    <!-- Modals -->
    <div id="optionsModal" class="fixed inset-0 modal-overlay hidden flex items-center justify-center p-4">
        <div class="bg-slate-800 w-full max-w-sm rounded-2xl p-6 border border-slate-600">
            <h3 class="text-xl font-bold text-white mb-4 border-b border-slate-700 pb-2">ì„¤ì •</h3>
            <div class="mb-5">
                <label class="text-xs text-slate-400 mb-2 block">ê²Œì„ ë°©ì‹</label>
                <div class="flex rounded-lg overflow-hidden border border-slate-600">
                    <button onclick="GameApp.setInputMode('word')" id="optModeWord" class="flex-1 py-2 text-sm bg-violet-600 text-white font-bold">ê·¸ëŒ€ë¡œ ì¹˜ê¸°</button>
                    <button onclick="GameApp.setInputMode('meaning')" id="optModeMean" class="flex-1 py-2 text-sm bg-slate-700 text-slate-300">ì •ë‹µ ë§íˆê¸°</button>
                </div>
            </div>
            <div class="mb-5">
                <div class="flex justify-between mb-1">
                    <label class="text-xs text-slate-400">ì†ë„</label>
                    <span id="speedValue" class="text-violet-400 font-bold text-xs">0.6</span>
                </div>
                <input type="range" id="speedSlider" min="0.5" max="5.0" step="0.1" value="0.6" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer">
            </div>
            <button onclick="GameApp.saveOptions()" class="w-full py-3 bg-violet-600 rounded-xl text-white font-bold">í™•ì¸</button>
        </div>
    </div>

    <div id="gameOverModal" class="fixed inset-0 modal-overlay hidden flex items-center justify-center p-6">
        <div class="bg-slate-800 w-full max-w-xs rounded-2xl p-6 text-center border border-slate-600 shadow-2xl">
            <div class="text-5xl mb-4 text-red-500 animate-pulse"><i class="fas fa-skull"></i></div>
            <h2 class="text-2xl font-bold text-white mb-1">GAME OVER</h2>
            <div class="bg-slate-900 rounded-lg p-3 mb-6 grid grid-cols-2 gap-2 text-sm mt-4">
                <div class="text-slate-400">ì ìˆ˜</div>
                <div id="finalScore" class="font-bold text-violet-400 text-right">0</div>
                <div class="text-slate-400">ìµœëŒ€ ì½¤ë³´</div>
                <div id="finalCombo" class="font-bold text-green-400 text-right">0</div>
            </div>
            <button onclick="GameApp.resetGame()" class="w-full py-3 bg-white text-slate-900 rounded-xl font-bold">ë©”ì¸ìœ¼ë¡œ</button>
        </div>
    </div>

    <script>
        // ë‹¨ì–´ì¥ ëª¨ë“ˆ
        const WordDataModules = {
            "english_basic": {
                name: "ğŸ‡ºğŸ‡¸ ìˆ˜ëŠ¥ í•„ìˆ˜ ì˜ë‹¨ì–´",
                data: [
                    {en: "abundant", ko: "í’ë¶€í•œ"}, {en: "accumulate", ko: "ì¶•ì í•˜ë‹¤"}, {en: "advocate", ko: "ì˜¹í˜¸í•˜ë‹¤"},
                    {en: "aesthetic", ko: "ë¯¸ì ì¸"}, {en: "aggressive", ko: "ê³µê²©ì ì¸"}, {en: "analyze", ko: "ë¶„ì„í•˜ë‹¤"},
                    {en: "anticipate", ko: "ì˜ˆìƒí•˜ë‹¤"}, {en: "artificial", ko: "ì¸ê³µì˜"}, {en: "attribute", ko: "ì†ì„±"},
                    {en: "benefit", ko: "ì´ìµ"}, {en: "bias", ko: "í¸ê²¬"}, {en: "candidate", ko: "í›„ë³´ì"},
                    {en: "capable", ko: "ìœ ëŠ¥í•œ"}, {en: "cease", ko: "ì¤‘ë‹¨í•˜ë‹¤"}, {en: "challenge", ko: "ë„ì „"},
                    {en: "characteristic", ko: "íŠ¹ì§•"}, {en: "circumstance", ko: "ìƒí™©"}, {en: "collaborate", ko: "í˜‘ë ¥í•˜ë‹¤"},
                    {en: "collapse", ko: "ë¶•ê´´í•˜ë‹¤"}, {en: "commit", ko: "ì €ì§€ë¥´ë‹¤"}, {en: "complex", ko: "ë³µì¡í•œ"},
                    {en: "component", ko: "êµ¬ì„±ìš”ì†Œ"}, {en: "concentrate", ko: "ì§‘ì¤‘í•˜ë‹¤"}, {en: "conclude", ko: "ê²°ë¡ ì§“ë‹¤"},
                    {en: "conflict", ko: "ê°ˆë“±"}, {en: "conscious", ko: "ì˜ì‹í•˜ëŠ”"}, {en: "consequence", ko: "ê²°ê³¼"},
                    {en: "constant", ko: "ì§€ì†ì ì¸"}, {en: "consume", ko: "ì†Œë¹„í•˜ë‹¤"}, {en: "contemporary", ko: "í˜„ëŒ€ì˜"},
                    {en: "contribute", ko: "ê¸°ì—¬í•˜ë‹¤"}, {en: "convince", ko: "ì„¤ë“í•˜ë‹¤"}, {en: "crucial", ko: "ì¤‘ëŒ€í•œ"},
                    {en: "decline", ko: "ê°ì†Œí•˜ë‹¤"}, {en: "define", ko: "ì •ì˜í•˜ë‹¤"}, {en: "demonstrate", ko: "ì¦ëª…í•˜ë‹¤"},
                    {en: "depend", ko: "ì˜ì¡´í•˜ë‹¤"}, {en: "determine", ko: "ê²°ì •í•˜ë‹¤"}, {en: "develop", ko: "ë°œì „í•˜ë‹¤"},
                    {en: "distinguish", ko: "êµ¬ë³„í•˜ë‹¤"}, {en: "distribute", ko: "ë¶„ë°°í•˜ë‹¤"}, {en: "diverse", ko: "ë‹¤ì–‘í•œ"},
                    {en: "dominate", ko: "ì§€ë°°í•˜ë‹¤"}, {en: "efficient", ko: "íš¨ìœ¨ì ì¸"}, {en: "eliminate", ko: "ì œê±°í•˜ë‹¤"},
                    {en: "emerge", ko: "ë‚˜íƒ€ë‚˜ë‹¤"}, {en: "emphasis", ko: "ê°•ì¡°"}, {en: "encourage", ko: "ê²©ë ¤í•˜ë‹¤"},
                    {en: "endure", ko: "ê²¬ë””ë‹¤"}, {en: "enhance", ko: "í–¥ìƒì‹œí‚¤ë‹¤"}, {en: "environment", ko: "í™˜ê²½"},
                    {en: "establish", ko: "ì„¤ë¦½í•˜ë‹¤"}, {en: "estimate", ko: "ì¶”ì •í•˜ë‹¤"}, {en: "evidence", ko: "ì¦ê±°"},
                    {en: "evolve", ko: "ì§„í™”í•˜ë‹¤"}, {en: "exaggerate", ko: "ê³¼ì¥í•˜ë‹¤"}, {en: "examine", ko: "ì¡°ì‚¬í•˜ë‹¤"},
                    {en: "exhaust", ko: "ê³ ê°ˆì‹œí‚¤ë‹¤"}, {en: "exhibit", ko: "ì „ì‹œí•˜ë‹¤"}, {en: "exist", ko: "ì¡´ì¬í•˜ë‹¤"},
                    {en: "expand", ko: "í™•ì¥í•˜ë‹¤"}, {en: "expect", ko: "ê¸°ëŒ€í•˜ë‹¤"}, {en: "experience", ko: "ê²½í—˜"},
                    {en: "experiment", ko: "ì‹¤í—˜"}, {en: "expert", ko: "ì „ë¬¸ê°€"}, {en: "explain", ko: "ì„¤ëª…í•˜ë‹¤"},
                    {en: "explore", ko: "íƒí—˜í•˜ë‹¤"}, {en: "feature", ko: "íŠ¹ì§•"}, {en: "financial", ko: "ì¬ì •ì ì¸"},
                    {en: "focus", ko: "ì´ˆì "}, {en: "function", ko: "ê¸°ëŠ¥"}, {en: "generate", ko: "ìƒì„±í•˜ë‹¤"},
                    {en: "guarantee", ko: "ë³´ì¥í•˜ë‹¤"}, {en: "hesitate", ko: "ë§ì„¤ì´ë‹¤"}, {en: "identify", ko: "ì‹ë³„í•˜ë‹¤"},
                    {en: "ignore", ko: "ë¬´ì‹œí•˜ë‹¤"}, {en: "illustrate", ko: "ì„¤ëª…í•˜ë‹¤"}, {en: "impact", ko: "ì˜í–¥"},
                    {en: "imply", ko: "ì•”ì‹œí•˜ë‹¤"}, {en: "indicate", ko: "ê°€ë¦¬í‚¤ë‹¤"}, {en: "individual", ko: "ê°œì¸ì˜"},
                    {en: "inevitable", ko: "í”¼í•  ìˆ˜ ì—†ëŠ”"}, {en: "influence", ko: "ì˜í–¥"}, {en: "inherit", ko: "ìƒì†í•˜ë‹¤"},
                    {en: "initial", ko: "ì²˜ìŒì˜"}, {en: "initiate", ko: "ì‹œì‘í•˜ë‹¤"}, {en: "innovate", ko: "í˜ì‹ í•˜ë‹¤"},
                    {en: "inquire", ko: "ë¬¸ì˜í•˜ë‹¤"}, {en: "insight", ko: "í†µì°°ë ¥"}, {en: "insist", ko: "ì£¼ì¥í•˜ë‹¤"},
                    {en: "inspire", ko: "ì˜ê°ì„ ì£¼ë‹¤"}, {en: "install", ko: "ì„¤ì¹˜í•˜ë‹¤"}, {en: "instance", ko: "ì‚¬ë¡€"},
                    {en: "intense", ko: "ê°•ë ¬í•œ"}, {en: "interpret", ko: "í•´ì„í•˜ë‹¤"}, {en: "interrupt", ko: "ë°©í•´í•˜ë‹¤"},
                    {en: "invest", ko: "íˆ¬ìí•˜ë‹¤"}, {en: "involve", ko: "í¬í•¨í•˜ë‹¤"}, {en: "isolate", ko: "ê³ ë¦½ì‹œí‚¤ë‹¤"}
                ]
            },
            "japanese_basic": {
                name: "ğŸ‡¯ğŸ‡µ ê¸°ì´ˆ ì¼ë³¸ì–´ (ë¡œë§ˆì)",
                data: [
                    {display: "çŒ«", match: "neko", effect: "ê³ ì–‘ì´"},
                    {display: "çŠ¬", match: "inu", effect: "ê°œ"},
                    {display: "å­¦ç”Ÿ", match: "gakusei", effect: "í•™ìƒ"},
                    {display: "å…ˆç”Ÿ", match: "sensei", effect: "ì„ ìƒë‹˜"},
                    {display: "å­¦æ ¡", match: "gakkou", effect: "í•™êµ"},
                    {display: "æ—¥æœ¬", match: "nihon", effect: "ì¼ë³¸"},
                    {display: "éŸ“å›½", match: "kankoku", effect: "í•œêµ­"},
                    {display: "ç§", match: "watashi", effect: "ë‚˜, ì €"},
                    {display: "æœ¬", match: "hon", effect: "ì±…"},
                    {display: "æ°´", match: "mizu", effect: "ë¬¼"},
                    {display: "é£Ÿã¹ã‚‹", match: "taberu", effect: "ë¨¹ë‹¤"},
                    {display: "è¡Œã", match: "iku", effect: "ê°€ë‹¤"},
                    {display: "æ¥ã‚‹", match: "kuru", effect: "ì˜¤ë‹¤"},
                    {display: "è¦‹ã‚‹", match: "miru", effect: "ë³´ë‹¤"},
                    {display: "å¥½ã", match: "suki", effect: "ì¢‹ì•„í•˜ë‹¤"},
                    {display: "æ„›", match: "ai", effect: "ì‚¬ë‘"},
                    {display: "å¤¢", match: "yume", effect: "ê¿ˆ"},
                    {display: "ç©º", match: "sora", effect: "í•˜ëŠ˜"},
                    {display: "æµ·", match: "umi", effect: "ë°”ë‹¤"},
                    {display: "å±±", match: "yama", effect: "ì‚°"},
                    {display: "èŠ±", match: "hana", effect: "ê½ƒ"},
                    {display: "æœˆ", match: "tsuki", effect: "ë‹¬"},
                    {display: "æ˜Ÿ", match: "hoshi", effect: "ë³„"},
                    {display: "é›¨", match: "ame", effect: "ë¹„"},
                    {display: "é›ª", match: "yuki", effect: "ëˆˆ"},
                    {display: "å‹é”", match: "tomodachi", effect: "ì¹œêµ¬"},
                    {display: "å®¶æ—", match: "kazoku", effect: "ê°€ì¡±"},
                    {display: "ä»Šæ—¥", match: "kyou", effect: "ì˜¤ëŠ˜"},
                    {display: "æ˜æ—¥", match: "ashita", effect: "ë‚´ì¼"},
                    {display: "æ˜¨æ—¥", match: "kinou", effect: "ì–´ì œ"}
                ]
            }
        };

        const UserConfig = {
            initialSpeed: 0.6,
            // initialSpawnRate: 3000,
            inputMode: 'word',
            levelUpScore: 200,
            rowHeight: 40, 
            limitX: 0
        };

        class Game {
            constructor() {
                this.words = [];
                this.wordBag = [];
                this.activeWords = [];
                this.gameState = {
                    score: 0, level: 1, isPlaying: false, isPaused: false, combo: 0,
                    currentSpeed: UserConfig.initialSpeed
                    // currentSpawnRate: UserConfig.initialSpawnRate
                };
                
                this.currentMovingWord = null;
                
                this.ui = {
                    startScreen: document.getElementById('startScreen'),
                    gameArea: document.getElementById('gameArea'),
                    input: document.getElementById('wordInput'),
                    fireBtn: document.getElementById('fireBtn'),
                    score: document.getElementById('scoreDisplay'),
                    gameOverModal: document.getElementById('gameOverModal'),
                    finalScore: document.getElementById('finalScore'),
                    finalCombo: document.getElementById('finalCombo'),
                    pauseBtn: document.getElementById('pauseBtn'),
                    stopBtn: document.getElementById('stopBtn'),
                    fileInput: document.getElementById('fileInput'),
                    optionsModal: document.getElementById('optionsModal'),
                    speedSlider: document.getElementById('speedSlider'),
                    speedValue: document.getElementById('speedValue'),
                    optModeWord: document.getElementById('optModeWord'),
                    optModeMean: document.getElementById('optModeMean'),
                    wordListSelect: document.getElementById('wordListSelect'),
                    wordCountPreview: document.getElementById('wordCountPreview'),
                    appLogoGroup: document.getElementById('appLogoGroup')
                };

                this.initVisualViewport();
                this.initWordListSelect();
                this.initEventListeners();
                this.loadWordList('english_basic');
            }

            initVisualViewport() {
                const handleResize = () => {
                    if (window.visualViewport) {
                        document.body.style.height = `${window.visualViewport.height}px`;
                        window.scrollTo(0, 0);
                    }
                };
                if (window.visualViewport) {
                    window.visualViewport.addEventListener('resize', handleResize);
                    window.visualViewport.addEventListener('scroll', () => window.scrollTo(0, 0));
                    handleResize();
                } else {
                    window.addEventListener('resize', () => {
                        document.body.style.height = `${window.innerHeight}px`;
                    });
                }
            }

            initWordListSelect() {
                for (const [key, module] of Object.entries(WordDataModules)) {
                    const option = document.createElement('option');
                    option.value = key;
                    option.text = module.name;
                    this.ui.wordListSelect.appendChild(option);
                }
                this.ui.wordListSelect.addEventListener('change', (e) => {
                    this.loadWordList(e.target.value);
                });
            }

            loadWordList(key) {
                const module = WordDataModules[key];
                if (module) {
                    this.sourceData = module.data;
                    this.processWords();
                    this.ui.wordCountPreview.innerText = `ë‹¨ì–´ ìˆ˜: ${this.words.length}ê°œ`;
                }
            }

            processWords() {
                this.words = this.sourceData.map(item => {
                    let display, match, effect;
                    let answers = [];

                    if (item.display && item.match && item.effect) {
                        if (UserConfig.inputMode === 'word') {
                            display = item.display;
                            match = [item.display]; 
                            effect = item.effect;
                        } else {
                            display = item.display; 
                            match = [item.match];
                            effect = item.effect;
                        }
                    }
                    else {
                        if (UserConfig.inputMode === 'word') {
                            display = item.en;
                            match = [item.en];
                            effect = item.ko;
                        } else {
                            display = item.en; 
                            let cleanStr = item.ko.replace(/\([^)]*\)/g, ''); 
                            answers = cleanStr.split(/[,;]/).map(s => s.trim()).filter(s => s.length > 0);
                            match = answers.length > 0 ? answers : [item.ko.trim()];
                            effect = item.ko;
                        }
                    }
                    return { display, match, effect };
                });
            }

            initEventListeners() {
                const handleInput = () => {
                    if (this.gameState.isPlaying && !this.gameState.isPaused) {
                        this.checkInput(this.ui.input.value.trim());
                        this.ui.input.value = '';
                    }
                };

                this.ui.input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') handleInput();
                });
                this.ui.fireBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    handleInput();
                    this.ui.input.focus();
                });

                this.ui.fileInput.addEventListener('change', (e) => this.loadFile(e));
                this.ui.pauseBtn.addEventListener('click', () => this.togglePause());
                
                this.ui.speedSlider.addEventListener('input', (e) => {
                    this.ui.speedValue.innerText = parseFloat(e.target.value).toFixed(1);
                });
            }

            loadFile(event) {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    const content = e.target.result;
                    const lines = content.split('\n');
                    const newSourceData = [];
                    lines.forEach(line => {
                        const parts = line.split(',').map(s=>s.trim());
                        if (parts.length >= 2) {
                            if(parts.length >=3) newSourceData.push({display: parts[0], match: parts[1], effect: parts[2]});
                            else newSourceData.push({en: parts[0], ko: parts[1]});
                        }
                    });

                    if (newSourceData.length > 0) {
                        this.sourceData = newSourceData;
                        this.processWords();
                        
                        const customKey = 'custom_' + Date.now();
                        WordDataModules[customKey] = {
                            name: `ğŸ“‚ ${file.name}`,
                            data: newSourceData
                        };
                        
                        const option = document.createElement('option');
                        option.value = customKey;
                        option.text = `ğŸ“‚ ${file.name}`;
                        this.ui.wordListSelect.appendChild(option);
                        this.ui.wordListSelect.value = customKey;

                        this.ui.wordCountPreview.innerText = `ë‹¨ì–´ ìˆ˜: ${this.words.length}ê°œ`;
                        alert(`íŒŒì¼ì—ì„œ ${newSourceData.length}ê°œì˜ ë‹¨ì–´ë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.`);
                    }
                };
                reader.readAsText(file);
                event.target.value = '';
            }

            startGame(mode) {
                this.processWords();
                this.gameState.mode = mode;
                this.gameState.isPlaying = true;
                this.gameState.isPaused = false;
                this.gameState.score = 0;
                this.gameState.combo = 0;
                this.activeWords = [];
                this.currentMovingWord = null;
                
                this.gameState.currentSpeed = UserConfig.initialSpeed;

                this.initWordBag();

                this.ui.appLogoGroup.classList.add('hidden');
                
                this.ui.startScreen.classList.add('hidden');
                this.ui.gameOverModal.classList.add('hidden');
                this.ui.pauseBtn.classList.remove('hidden');
                this.ui.stopBtn.classList.remove('hidden');
                this.ui.input.disabled = false;
                this.ui.input.focus();
                this.ui.score.innerText = '0';
                
                this.lastTime = performance.now();
                this.gameLoop(this.lastTime);
            }

            initWordBag() {
                this.wordBag = Array.from({length: this.words.length}, (_, i) => i);
            }

            spawnWord() {
                if(this.wordBag.length === 0) this.initWordBag();
                const idx = this.wordBag.splice(Math.floor(Math.random() * this.wordBag.length), 1)[0];
                const wordData = this.words[idx];
                
                const gameHeight = this.ui.gameArea.clientHeight;
                const maxRows = Math.floor(gameHeight / UserConfig.rowHeight);
                const randomRow = Math.floor(Math.random() * maxRows);
                const y = randomRow * UserConfig.rowHeight;

                const el = document.createElement('div');
                el.className = 'word-block';
                el.innerText = wordData.display;
                el.style.left = `-150px`; 
                el.style.top = `${y + 2}px`;
                this.ui.gameArea.appendChild(el);

                const width = el.offsetWidth;
                
                const newWord = {
                    id: Math.random(),
                    data: wordData,
                    x: -150,
                    y: y + 2,
                    width: width,
                    height: 34,
                    row: randomRow,
                    element: el,
                    isStacked: false
                };

                this.activeWords.push(newWord);
                this.currentMovingWord = newWord;
            }

            gameLoop(timestamp) {
                if (!this.gameState.isPlaying || this.gameState.isPaused) return;
                const deltaTime = timestamp - this.lastTime;
                this.lastTime = timestamp;

                if (!this.currentMovingWord) {
                    this.spawnWord();
                }

                const gameWidth = this.ui.gameArea.clientWidth;

                this.checkStackStability(gameWidth);

                this.activeWords.forEach(word => {
                    if (word.isStacked) return;

                    const move = this.gameState.currentSpeed * (deltaTime / 16);
                    let newX = word.x + move;
                    let hasLanded = false;

                    if (newX + word.width >= gameWidth) {
                        newX = gameWidth - word.width;
                        hasLanded = true;
                    }

                    if (!hasLanded) {
                        for (const other of this.activeWords) {
                            if (other === word || !other.isStacked) continue;
                            if (other.row === word.row) {
                                if (word.x < other.x && newX + word.width >= other.x) {
                                    newX = other.x - word.width - 2;
                                    hasLanded = true;
                                    break;
                                }
                            }
                        }
                    }

                    word.x = newX;
                    word.element.style.left = `${word.x}px`;

                    if (hasLanded) {
                        word.isStacked = true;
                        word.element.classList.add('stacked');
                        
                        if (this.currentMovingWord === word) {
                            this.currentMovingWord = null;
                        }

                        if (word.x <= UserConfig.limitX) {
                            if (this.gameState.mode === 'practice') {
                                this.removeWord(word);
                            } else {
                                this.gameOver();
                            }
                        }
                    }
                });

                requestAnimationFrame((t) => this.gameLoop(t));
            }

            checkStackStability(gameWidth) {
                this.activeWords.forEach(word => {
                    if (!word.isStacked) return;
                    
                    if (word.x + word.width >= gameWidth - 2) return; 

                    let hasSupport = false;
                    for (const other of this.activeWords) {
                        if (other === word || !other.isStacked) continue;
                        
                        if (other.row === word.row) {
                            const dist = other.x - (word.x + word.width);
                            if (dist >= -2 && dist <= 5) {
                                hasSupport = true;
                                break;
                            }
                        }
                    }

                    if (!hasSupport) {
                        word.isStacked = false;
                        word.element.classList.remove('stacked');
                    }
                });
            }

            checkInput(text) {
                if (!text) return;
                const matches = this.activeWords.filter(w => 
                    w.data.match.some(m => m.toLowerCase() === text.toLowerCase())
                );
                
                if (matches.length > 0) {
                    matches.sort((a, b) => b.x - a.x);
                    this.removeWord(matches[0]);
                    this.addScore();
                }
            }

            removeWord(word) {
                this.activeWords = this.activeWords.filter(w => w.id !== word.id);
                word.element.remove();
                
                if (this.currentMovingWord === word) {
                    this.currentMovingWord = null;
                }
                
                const effect = document.createElement('div');
                effect.className = 'meaning-afterimage';
                effect.innerText = word.data.effect;
                effect.style.left = `${word.x}px`;
                effect.style.top = `${word.y}px`;
                this.ui.gameArea.appendChild(effect);
                setTimeout(() => effect.remove(), 600);
            }

            addScore() {
                this.gameState.score += 10 + (this.gameState.combo * 2);
                this.gameState.combo++;
                this.ui.score.innerText = this.gameState.score;
            }

            gameOver() {
                this.gameState.isPlaying = false;
                this.ui.finalScore.innerText = this.gameState.score;
                this.ui.finalCombo.innerText = this.gameState.combo;
                this.ui.gameOverModal.classList.remove('hidden');
                this.ui.input.blur();
            }

            resetGame() {
                this.gameState.isPlaying = false;
                this.gameState.isPaused = false;
                this.activeWords.forEach(w => w.element.remove());
                this.activeWords = [];
                this.currentMovingWord = null;
                document.querySelectorAll('.meaning-afterimage').forEach(el => el.remove());

                this.ui.appLogoGroup.classList.remove('hidden');

                this.ui.startScreen.classList.remove('hidden');
                this.ui.gameOverModal.classList.add('hidden');
                this.ui.pauseBtn.classList.add('hidden');
                this.ui.stopBtn.classList.add('hidden');
                this.ui.input.disabled = true;
                this.ui.input.value = '';
            }

            openOptions() { this.ui.optionsModal.classList.remove('hidden'); }
            
            saveOptions() {
                UserConfig.inputMode = this.ui.optModeWord.classList.contains('bg-violet-600') ? 'word' : 'meaning';
                UserConfig.initialSpeed = parseFloat(this.ui.speedSlider.value);
                
                this.gameState.currentSpeed = UserConfig.initialSpeed;

                this.ui.optionsModal.classList.add('hidden');
                this.processWords();
            }

            setInputMode(mode) {
                if (mode === 'word') {
                    this.ui.optModeWord.className = 'flex-1 py-2 text-sm bg-violet-600 text-white font-bold';
                    this.ui.optModeMean.className = 'flex-1 py-2 text-sm bg-slate-700 text-slate-300';
                } else {
                    this.ui.optModeWord.className = 'flex-1 py-2 text-sm bg-slate-700 text-slate-300';
                    this.ui.optModeMean.className = 'flex-1 py-2 text-sm bg-violet-600 text-white font-bold';
                }
            }

            togglePause() {
                if (!this.gameState.isPlaying) return;
                this.gameState.isPaused = !this.gameState.isPaused;
                this.ui.pauseBtn.innerHTML = this.gameState.isPaused ? '<i class="fas fa-play"></i>' : '<i class="fas fa-pause"></i>';
                
                if (this.gameState.isPaused) {
                    this.ui.input.disabled = true;
                    this.ui.input.placeholder = "ì¼ì‹œì •ì§€";
                } else {
                    this.ui.input.disabled = false;
                    this.ui.input.placeholder = "ì…ë ¥...";
                    this.ui.input.focus();
                    this.lastTime = performance.now();
                    this.gameLoop(this.lastTime);
                }
            }
        }

        const GameApp = new Game();
    </script>
</body>
</html>
